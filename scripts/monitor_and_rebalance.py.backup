#!/usr/bin/env python3
"""
Automated LP Position Monitor and Rebalancer

This script continuously monitors a Uniswap V3 LP position and automatically
rebalances when the price moves out of range.

MVP Specifications:
- Position range: ±50 ticks (±0.5% from current price)
- Check interval: Every 1 minute
- Auto-rebalance: When price exits the position's tick range

Usage:
    python scripts/monitor_and_rebalance.py --pool WETH-USDC --fee 500 --amount0 0.0001 --amount1 0.2
"""

import argparse
import time
import sys
from pathlib import Path

# Add src to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from src.dex.uniswap import get_uniswap
from src.dex.abis import POOL_ABI
from src.utils.config import get_config
from src.utils.logger import log as logger


class PositionMonitor:
    """Monitors and rebalances Uniswap V3 LP positions"""
    
    def __init__(self, pool_name: str, fee: int, tick_range: int = 50, check_interval: int = 60):
        """
        Initialize the position monitor
        
        Args:
            pool_name: Pool identifier (e.g., "WETH-USDC")
            fee: Fee tier in bps (e.g., 500 = 0.05%)
            tick_range: Number of ticks for position range (default: 50 = ±0.5%)
            check_interval: Seconds between range checks (default: 60)
        """
        self.pool_name = pool_name
        self.fee = fee
        self.tick_range = tick_range
        self.check_interval = check_interval
        self.current_position_id = None
        
        # Initialize clients
        self.config = get_config()
        self.uniswap = get_uniswap()
        
        logger.info(f"Initialized PositionMonitor for {pool_name} (fee: {fee/10000}%)")
        logger.info(f"Tick range: ±{tick_range} ticks (~±{tick_range/100}%)")
        logger.info(f"Check interval: {check_interval} seconds")
    
    def get_pool_tokens(self) -> tuple:
        """Parse pool name to get token addresses"""
        token_map = {
            'WETH': '0x4200000000000000000000000000000000000006',
            'USDC': '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
            'USDbC': '0xd9aAEc86B65D86f6A7B5B1b0c42FFA531710b6CA',
            'cbETH': '0x2Ae3F1Ec7F1F5012CFEab0185bfc7aa3cf0DEc22',
            'DAI': '0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb'
        }
        
        tokens = self.pool_name.split('-')
        if len(tokens) != 2:
            raise ValueError(f"Invalid pool name: {self.pool_name}. Expected format: TOKEN0-TOKEN1")
        
        token0_addr = token_map.get(tokens[0])
        token1_addr = token_map.get(tokens[1])
        
        if not token0_addr or not token1_addr:
            raise ValueError(f"Unknown token in pool name. Available: {list(token_map.keys())}")
        
        return token0_addr, token1_addr
    
    def create_position(self, amount0: float, amount1: float) -> int:
        """
        Create a new LP position centered around current price
        
        Args:
            amount0: Amount of token0 to deposit
            amount1: Amount of token1 to deposit
            
        Returns:
            Position NFT token ID
        """
        logger.info(f"Creating new position with {amount0} token0 and {amount1} token1")
        
        token0, token1 = self.get_pool_tokens()
        
        # Get current pool price and calculate tick range
        pool_address = self.uniswap.get_pool(token0, token1, self.fee)
        current_price = self.uniswap.get_pool_price(pool_address)
        
        logger.info(f"Current pool price: {current_price}")
        
        # Get current tick from pool
        pool_contract = self.uniswap.w3.eth.contract(
            address=pool_address,
            abi=POOL_ABI
        )
        slot0 = pool_contract.functions.slot0().call()
        current_tick = slot0[1]
        tick_spacing = pool_contract.functions.tickSpacing().call()
        
        logger.info(f"Current tick: {current_tick}, Tick spacing: {tick_spacing}")
        
        # Calculate tick range (±50 ticks from current)
        # Round to nearest valid tick
        tick_lower = ((current_tick - self.tick_range) // tick_spacing) * tick_spacing
        tick_upper = ((current_tick + self.tick_range) // tick_spacing) * tick_spacing
        
        logger.info(f"Position range: [{tick_lower}, {tick_upper}]")
        
        # Create the position
        tx_hash, token_id = self.uniswap.add_liquidity(
            token0=token0,
            token1=token1,
            fee=self.fee,
            amount0=amount0,
            amount1=amount1,
            tick_lower=tick_lower,
            tick_upper=tick_upper
        )
        
        logger.info(f"✅ Position created! Token ID: {token_id}")
        logger.info(f"Transaction: https://basescan.org/tx/{tx_hash.hex()}")
        
        return token_id
    
    def check_position_range(self, token_id: int) -> dict:
        """
        Check if position is in range
        
        Args:
            token_id: Position NFT token ID
            
        Returns:
            Dict with status info: {in_range: bool, current_tick: int, tick_lower: int, tick_upper: int}
        """
        # Get position details
        position = self.uniswap.position_manager.functions.positions(token_id).call()
        tick_lower = position[5]
        tick_upper = position[6]
        token0 = position[2]
        token1 = position[3]
        fee = position[4]
        
        # Get current tick from pool
        pool_address = self.uniswap.get_pool(token0, token1, fee)
        pool_contract = self.uniswap.w3.eth.contract(
            address=pool_address,
            abi=POOL_ABI
        )
        slot0 = pool_contract.functions.slot0().call()
        current_tick = slot0[1]
        
        in_range = tick_lower <= current_tick <= tick_upper
        
        result = {
            'in_range': in_range,
            'current_tick': current_tick,
            'tick_lower': tick_lower,
            'tick_upper': tick_upper,
            'distance_from_lower': current_tick - tick_lower,
            'distance_from_upper': tick_upper - current_tick
        }
        
        logger.debug(f"Position check: {result}")
        
        return result
    
    def remove_position(self, token_id: int) -> tuple:
        """
        Remove all liquidity from a position
        
        Args:
            token_id: Position NFT token ID
            
        Returns:
            Tuple of (amount0_collected, amount1_collected)
        """
        logger.info(f"Removing liquidity from position {token_id}")
        
        # Get position details
        position = self.uniswap.position_manager.functions.positions(token_id).call()
        liquidity = position[7]
        
        if liquidity == 0:
            logger.warning(f"Position {token_id} has no liquidity")
            return (0, 0)
        
        # Build decrease liquidity params
        params = (
            token_id,
            liquidity,  # Remove all liquidity
            0,  # amount0Min (no slippage check for now)
            0,  # amount1Min (no slippage check for now)
            int(time.time()) + 300  # deadline: 5 minutes
        )
        
        # Send transaction
        tx_hash = self.uniswap.send_transaction(
            self.uniswap.position_manager.functions.decreaseLiquidity(params)
        )
        
        logger.info(f"Liquidity removed: {tx_hash.hex()}")
        
        # Collect the tokens
        collect_params = (
            token_id,
            self.uniswap.wallet_address,
            2**128 - 1,  # amount0Max (collect all)
            2**128 - 1   # amount1Max (collect all)
        )
        
        tx_hash = self.uniswap.send_transaction(
            self.uniswap.position_manager.functions.collect(collect_params)
        )
        
        logger.info(f"Tokens collected: {tx_hash.hex()}")
        
        # Get amounts from transaction receipt
        receipt = self.uniswap.w3.eth.wait_for_transaction_receipt(tx_hash)
        
        # Parse the Collect event to get actual amounts
        # For now, just return success indicator
        return (True, True)
    
    def rebalance_position(self, old_token_id: int, amount0: float, amount1: float) -> int:
        """
        Rebalance position: remove old position and create new one
        
        Args:
            old_token_id: Token ID of position to close
            amount0: Amount of token0 for new position
            amount1: Amount of token1 for new position
            
        Returns:
            New position token ID
        """
        logger.info("🔄 Starting rebalance...")
        
        # Remove old position
        self.remove_position(old_token_id)
        
        # Wait a bit for tokens to settle
        time.sleep(2)
        
        # Create new position
        new_token_id = self.create_position(amount0, amount1)
        
        logger.info(f"✅ Rebalance complete! New position: {new_token_id}")
        
        return new_token_id
    
    def monitor_loop(self, initial_amount0: float, initial_amount1: float, 
                    initial_token_id: int = None):
        """
        Main monitoring loop
        
        Args:
            initial_amount0: Initial amount of token0
            initial_amount1: Initial amount of token1
            initial_token_id: Existing position ID (if None, creates new position)
        """
        # Create initial position if needed
        if initial_token_id is None:
            logger.info("No existing position, creating initial position...")
            self.current_position_id = self.create_position(initial_amount0, initial_amount1)
        else:
            logger.info(f"Using existing position: {initial_token_id}")
            self.current_position_id = initial_token_id
        
        logger.info("🚀 Starting monitoring loop...")
        logger.info(f"Will check position every {self.check_interval} seconds")
        
        rebalance_count = 0
        check_count = 0
        
        try:
            while True:
                check_count += 1
                
                # Check if position is in range
                status = self.check_position_range(self.current_position_id)
                
                # Get position details for price calculation
                position = self.uniswap.position_manager.functions.positions(self.current_position_id).call()
                token0 = position[2]
                token1 = position[3]
                fee = position[4]
                
                # Get current price from pool
                pool_address = self.uniswap.get_pool(token0, token1, fee)
                current_price = self.uniswap.get_pool_price(pool_address)
                
                # Calculate price bounds from ticks
                price_lower = 1.0001 ** status['tick_lower']
                price_upper = 1.0001 ** status['tick_upper']
                
                # Print detailed status header
                logger.info("=" * 80)
                logger.info(f"📊 CHECK #{check_count} - {self.pool_name} Position {self.current_position_id}")
                logger.info("=" * 80)
                logger.info(f"💰 Current Price: {current_price:.6f} {self.pool_name.split('-')[1]} per {self.pool_name.split('-')[0]}")
                logger.info(f"📏 Position Bounds:")
                logger.info(f"   Lower: {price_lower:.6f} (tick {status['tick_lower']})")
                logger.info(f"   Upper: {price_upper:.6f} (tick {status['tick_upper']})")
                logger.info(f"🎯 Current Tick: {status['current_tick']}")
                logger.info(f"📍 Distance from Lower Edge: {status['distance_from_lower']} ticks")
                logger.info(f"📍 Distance from Upper Edge: {status['distance_from_upper']} ticks")
                
                if status['in_range']:
                    # Calculate how centered the price is
                    total_range = status['tick_upper'] - status['tick_lower']
                    position_pct = ((status['current_tick'] - status['tick_lower']) / total_range * 100) if total_range > 0 else 50
                    
                    logger.info(f"✅ STATUS: IN RANGE ({position_pct:.1f}% through range)")
                    logger.info(f"📈 Total Rebalances: {rebalance_count}")
                else:
                    if status['current_tick'] < status['tick_lower']:
                        direction = "BELOW"
                        distance = status['tick_lower'] - status['current_tick']
                    else:
                        direction = "ABOVE"
                        distance = status['current_tick'] - status['tick_upper']
                    
                    logger.warning(f"⚠️  STATUS: OUT OF RANGE ({direction} by {distance} ticks)")
                    logger.warning(f"🔧 ACTION REQUIRED: Rebalancing position...")
                    
                    # Rebalance the position
                    logger.info("=" * 80)
                    self.current_position_id = self.rebalance_position(
                        self.current_position_id,
                        initial_amount0,
                        initial_amount1
                    )
                    rebalance_count += 1
                    logger.info("=" * 80)
                    logger.info(f"✅ REBALANCE COMPLETE!")
                    logger.info(f"📈 Total Rebalances: {rebalance_count}")
                    logger.info(f"🆕 New Position ID: {self.current_position_id}")
                
                logger.info("=" * 80)
                logger.info(f"⏳ Next check in {self.check_interval} seconds...")
                logger.info("=" * 80)
                logger.info("")  # Blank line for readability
                
                # Wait before next check
                time.sleep(self.check_interval)
                
        except KeyboardInterrupt:
            logger.info("\n⛔ Monitoring stopped by user")
            logger.info(f"Final position ID: {self.current_position_id}")
            logger.info(f"Total rebalances performed: {rebalance_count}")
        except Exception as e:
            logger.error(f"❌ Error in monitoring loop: {e}", exc_info=True)
            raise


def main():
    parser = argparse.ArgumentParser(description='Monitor and rebalance Uniswap V3 LP position')
    parser.add_argument('--pool', type=str, required=True, 
                       help='Pool name (e.g., WETH-USDC)')
    parser.add_argument('--fee', type=int, required=True,
                       help='Fee tier in basis points (e.g., 500 for 0.05%%)')
    parser.add_argument('--amount0', type=float, required=True,
                       help='Amount of token0 to deposit')
    parser.add_argument('--amount1', type=float, required=True,
                       help='Amount of token1 to deposit')
    parser.add_argument('--tick-range', type=int, default=50,
                       help='Tick range for position (default: 50 = ±0.5%%)')
    parser.add_argument('--interval', type=int, default=60,
                       help='Check interval in seconds (default: 60)')
    parser.add_argument('--position-id', type=int, default=None,
                       help='Existing position token ID (if resuming monitoring)')
    
    args = parser.parse_args()
    
    # Create monitor
    monitor = PositionMonitor(
        pool_name=args.pool,
        fee=args.fee,
        tick_range=args.tick_range,
        check_interval=args.interval
    )
    
    # Start monitoring
    monitor.monitor_loop(
        initial_amount0=args.amount0,
        initial_amount1=args.amount1,
        initial_token_id=args.position_id
    )


if __name__ == '__main__':
    main()
